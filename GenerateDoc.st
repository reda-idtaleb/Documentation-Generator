Object subclass: #AbstractGenerateDoc	instanceVariableNames: 'class package'	classVariableNames: ''	package: 'GenerateDoc'!!AbstractGenerateDoc commentStamp: 'idtalebreda 2/2/2021 17:54' prior: 0!I am AbstractGenerateDoc, and i'm used to generate a full documentation of a class or a package.The documentation is generated as a file containing :	- the superclass of the class 	- all the subclasses	- all the methods 	- all the instance variables 	If 	the argument is a class then one file will generated.if the argument is a package then the program generates as many files as there are classes contained in the package	 Note: - all the generated files will be named by the name of the appropriate classes.	 		- the files are generated in the working directory. - the same directory in which you run the program -- To read: 	-> if you want to generate a documentation of only one class, you can pass in argument either the name of the class (as a String) or the class itself.	-> if you want to generate a documentation of a package, you can pass only in argument the name of the package( as a String).- Examples of how to generate documentation :    "#################### with the name of a class as String ####################"	| sClassDoc |	sClassDoc := AbstractGenerateDoc withClass: 'String' .	sClassDoc generateDoc 		"#################### with a class ####################"	| classDoc |	classDoc := AbstractGenerateDoc withClass: String .	classDoc generateDoc 		"#################### with a package(as a String) ####################"	| packDoc |	packDoc := AbstractGenerateDoc withClass: 'Files' .	packDoc generateDoc 	!!AbstractGenerateDoc methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 12:58'!generateDoc	"generate a file containing a doc of a class or of a package"	^self subclassResponsibility 	! !!AbstractGenerateDoc methodsFor: 'accessing' stamp: 'idtalebreda 2/1/2021 22:29'!package	^ package! !!AbstractGenerateDoc methodsFor: 'accessing' stamp: 'idtalebreda 2/2/2021 00:32'!setClass: anObject	class := anObject! !!AbstractGenerateDoc methodsFor: 'accessing' stamp: 'idtalebreda 2/1/2021 22:29'!package: anObject	package := anObject! !!AbstractGenerateDoc methodsFor: 'accessing' stamp: 'idtalebreda 2/1/2021 22:30'!getClass	^ class! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AbstractGenerateDoc class	instanceVariableNames: ''!!AbstractGenerateDoc class methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 15:31'!verifyArgumentPackage: arg	"this method is called when instantiating the 'GenerateDoc Class' with a package as argument.	 However, we can pass the package name only in a String type. otherwise, an error will be raised	" 	| validArg |	arg class superclass == String		ifTrue: [ validArg := arg asPackage ]		ifFalse: [ ^(Error signal: 'The argument must be a String ')  ].	^validArg		! !!AbstractGenerateDoc class methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 15:57'!verifyArgumentClass: arg	"this method checks the type of the argument passed to a GenerateDoc Class. 	- if the argument is of type String, then we try to convert it to the appropriate type (either a class or a package). 	- otherwise, we check for the existence of the class passed as an argument	"	| validArg |	arg class superclass == String		ifTrue: [ validArg := arg asClass ]		ifFalse: [ arg isClass				ifTrue: [ validArg := arg ]				ifFalse: [ ^ Error signal: 'the argument is not a valid class ' ] ].	^ validArg! !!AbstractGenerateDoc class methodsFor: 'accessing' stamp: 'idtalebreda 2/2/2021 15:23'!withClass: aClass	" create an instance of GeneratedDocClass with specified class	  - if the argument is a string then we convert the argument to a class if possible	  - if the argument is a class	then we check if it's a valid class. So an error will be raised if the class is not a valid Class	"	| validClass |	validClass := self verifyArgumentClass: aClass.	^ GenerateDocClass new setClass: validClass! !!AbstractGenerateDoc class methodsFor: 'accessing' stamp: 'idtalebreda 2/2/2021 15:23'!withPackage: aPackage	| validPack |	validPack := self verifyArgumentPackage: aPackage.	^ GenerateDocPackage new package: validPack ! !AbstractGenerateDoc subclass: #GenerateDocPackage	instanceVariableNames: ''	classVariableNames: ''	package: 'GenerateDoc-GenerateDocPackage'!!GenerateDocPackage commentStamp: 'idtalebreda 2/2/2021 17:55' prior: 0!I am GenerateDocPackage, and i generate a documentation of a package!AbstractGenerateDoc subclass: #GenerateDocClass	instanceVariableNames: ''	classVariableNames: ''	package: 'GenerateDoc-GenerateDocClass'!!GenerateDocClass commentStamp: 'idtalebreda 2/2/2021 17:55' prior: 0!I am GenerateDocClass, and i generate a documentation of a class!!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:24'!extractSubClasses	"return an array containing all the subclasses of a class"	^ self getClass class subclasses ! !!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:08'!generateDoc	"generate a file containing a doc of a class"	| nameClass file lineFd|	lineFd := Character linefeed asString.	nameClass := self getClass class name asString, '.txt'.	file := nameClass asFileReference .	file writeStreamDo: [ :stream | 		stream 		nextPutAll: ' - ClasseName: ', self extractClassName ;		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, ' - SuperClasse: ', self extractSuperClass ;		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, ' - SubClasses: ', self writeSubClasses;		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, ' - Methods Summary: ';		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, self writeMethods;		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, ' - Instance variables:  ', self writeInstanceVariable ]! !!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:24'!extractClassName	"return a string that represent the name of class"	^self getClass class name! !!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:24'!extractInstanceVariables	"return a string containing all the instances varaibles of a class separated by a space"	| res |	res := self getClass class instVarNames.	^  res! !!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:24'!extractAllMethods	"return an array containing all the methods of a class  "	| arrayMethods dictMethods i|	i := 1.	dictMethods := self getClass class methodDict.	arrayMethods := Array new: dictMethods size.	dictMethods do: 		[ :each | arrayMethods at: i put: each .		  i := i + 1		].	^ arrayMethods! !!GenerateDocClass methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:24'!extractSuperClass 	"return a string that indicate the super class of a specified class"	^ self getClass class superclass asString  ! !!GenerateDocClass methodsFor: 'writing' stamp: 'idtalebreda 2/2/2021 14:24'!writeSubClasses	"return a string containing all the subclasses separated by a space "	| res |	res := self extractSubClasses .	(res isEmpty) ifTrue: [^ 'no subclasses' ].	^ ', ' join: res! !!GenerateDocClass methodsFor: 'writing' stamp: 'idtalebreda 2/2/2021 14:24'!writeInstanceVariable	"return a string containing all the instance variables separated by a space "	| res |	res := self extractInstanceVariables .	(res isEmpty) ifTrue: [ ^ 'No instance variables' ].	^ Character space join: res! !!GenerateDocClass methodsFor: 'writing' stamp: 'idtalebreda 2/2/2021 16:03'!writeMethods	" return a string containing all the methods name separated by a space"	| allMethods s lineFd |	lineFd := Character linefeed asString.	s := String new.	allMethods := self extractAllMethods .	allMethods isEmpty		ifTrue: [ ^ ' No methods' ].		allMethods asString		do: [ :each | 			(each == ${ or: each == $})				ifTrue: [  ]				ifFalse: [ s := each == $.						     ifTrue: [ s, lineFd ]						     ifFalse: [ s, each asString ] 						   ] 			 ].	^ s! !!GenerateDocPackage methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 13:37'!extractClasses	"return an array containing all the classes of a package"	| arrayClasses set i|	i := 1.	set := self package package classes.	arrayClasses := Array new: set size.	set do: 		[ :each | arrayClasses at: i put: each .		  i := i + 1		].	^ arrayClasses	! !!GenerateDocPackage methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 14:16'!writeEmptyPackage	"if a package does not contain any class, we generate a file named by the name of the package, 	 and we indicate in it that this package does not contain any class 	"	| file namePackage lineFd|	lineFd := Character linefeed asString.	namePackage := self package package name asString, '.txt'.	file := namePackage asFileReference .	file writeStreamDo: [ :stream | 		stream 		nextPutAll: ' - packageName: ', namePackage ;		nextPutAll: lineFd, '-------------------------------------------------------------------------------------------';		nextPutAll: lineFd, ' - this package does not contain any class ']	! !!GenerateDocPackage methodsFor: 'method' stamp: 'idtalebreda 2/2/2021 16:05'!generateDoc	"generate for each class contained in the package its documentation file"	| classes generateClass |	classes := self extractClasses.	classes isEmpty		ifTrue: [ "if the package does not contain any class" self writeEmptyPackage ]		ifFalse: [ classes				do: [ :each | 					generateClass := self asGenerateDocClass: each.					generateClass generateDoc ] ]! !!GenerateDocPackage methodsFor: 'converting' stamp: 'idtalebreda 2/2/2021 14:23'!asGenerateDocClass: aClass	"convert a class to a generatDocClass 	 the convertion succeeds if and only if the class specified in argument exists, 	 otherwise an error will be raised	"	(aClass isClass ) ifTrue: [ ^ AbstractGenerateDoc withClass: aClass ]							 ifFalse: [^(Error signal: 'the argument is not a valid class')  ]	! !